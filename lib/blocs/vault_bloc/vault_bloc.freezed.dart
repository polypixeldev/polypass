// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'vault_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$VaultState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(int errorCount) opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)
        unlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function(int errorCount)? opening,
    TResult? Function(VaultFile vault)? locked,
    TResult? Function(VaultFile vault)? unlocking,
    TResult? Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(int errorCount)? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_Opening value)? opening,
    TResult? Function(_Locked value)? locked,
    TResult? Function(_Unlocking value)? unlocking,
    TResult? Function(_Unlocked value)? unlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VaultStateCopyWith<$Res> {
  factory $VaultStateCopyWith(
          VaultState value, $Res Function(VaultState) then) =
      _$VaultStateCopyWithImpl<$Res, VaultState>;
}

/// @nodoc
class _$VaultStateCopyWithImpl<$Res, $Val extends VaultState>
    implements $VaultStateCopyWith<$Res> {
  _$VaultStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_NoneCopyWith<$Res> {
  factory _$$_NoneCopyWith(_$_None value, $Res Function(_$_None) then) =
      __$$_NoneCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NoneCopyWithImpl<$Res>
    extends _$VaultStateCopyWithImpl<$Res, _$_None>
    implements _$$_NoneCopyWith<$Res> {
  __$$_NoneCopyWithImpl(_$_None _value, $Res Function(_$_None) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_None implements _None {
  const _$_None();

  @override
  String toString() {
    return 'VaultState.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_None);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(int errorCount) opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)
        unlocked,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function(int errorCount)? opening,
    TResult? Function(VaultFile vault)? locked,
    TResult? Function(VaultFile vault)? unlocking,
    TResult? Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(int errorCount)? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_Opening value)? opening,
    TResult? Function(_Locked value)? locked,
    TResult? Function(_Unlocking value)? unlocking,
    TResult? Function(_Unlocked value)? unlocked,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class _None implements VaultState {
  const factory _None() = _$_None;
}

/// @nodoc
abstract class _$$_OpeningCopyWith<$Res> {
  factory _$$_OpeningCopyWith(
          _$_Opening value, $Res Function(_$_Opening) then) =
      __$$_OpeningCopyWithImpl<$Res>;
  @useResult
  $Res call({int errorCount});
}

/// @nodoc
class __$$_OpeningCopyWithImpl<$Res>
    extends _$VaultStateCopyWithImpl<$Res, _$_Opening>
    implements _$$_OpeningCopyWith<$Res> {
  __$$_OpeningCopyWithImpl(_$_Opening _value, $Res Function(_$_Opening) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorCount = null,
  }) {
    return _then(_$_Opening(
      errorCount: null == errorCount
          ? _value.errorCount
          : errorCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Opening implements _Opening {
  const _$_Opening({this.errorCount = 0});

  @override
  @JsonKey()
  final int errorCount;

  @override
  String toString() {
    return 'VaultState.opening(errorCount: $errorCount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Opening &&
            (identical(other.errorCount, errorCount) ||
                other.errorCount == errorCount));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorCount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OpeningCopyWith<_$_Opening> get copyWith =>
      __$$_OpeningCopyWithImpl<_$_Opening>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(int errorCount) opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)
        unlocked,
  }) {
    return opening(errorCount);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function(int errorCount)? opening,
    TResult? Function(VaultFile vault)? locked,
    TResult? Function(VaultFile vault)? unlocking,
    TResult? Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
  }) {
    return opening?.call(errorCount);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(int errorCount)? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
    required TResult orElse(),
  }) {
    if (opening != null) {
      return opening(errorCount);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) {
    return opening(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_Opening value)? opening,
    TResult? Function(_Locked value)? locked,
    TResult? Function(_Unlocking value)? unlocking,
    TResult? Function(_Unlocked value)? unlocked,
  }) {
    return opening?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) {
    if (opening != null) {
      return opening(this);
    }
    return orElse();
  }
}

abstract class _Opening implements VaultState {
  const factory _Opening({final int errorCount}) = _$_Opening;

  int get errorCount;
  @JsonKey(ignore: true)
  _$$_OpeningCopyWith<_$_Opening> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_LockedCopyWith<$Res> {
  factory _$$_LockedCopyWith(_$_Locked value, $Res Function(_$_Locked) then) =
      __$$_LockedCopyWithImpl<$Res>;
  @useResult
  $Res call({VaultFile vault});

  $VaultFileCopyWith<$Res> get vault;
}

/// @nodoc
class __$$_LockedCopyWithImpl<$Res>
    extends _$VaultStateCopyWithImpl<$Res, _$_Locked>
    implements _$$_LockedCopyWith<$Res> {
  __$$_LockedCopyWithImpl(_$_Locked _value, $Res Function(_$_Locked) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vault = null,
  }) {
    return _then(_$_Locked(
      null == vault
          ? _value.vault
          : vault // ignore: cast_nullable_to_non_nullable
              as VaultFile,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $VaultFileCopyWith<$Res> get vault {
    return $VaultFileCopyWith<$Res>(_value.vault, (value) {
      return _then(_value.copyWith(vault: value));
    });
  }
}

/// @nodoc

class _$_Locked implements _Locked {
  const _$_Locked(this.vault);

  @override
  final VaultFile vault;

  @override
  String toString() {
    return 'VaultState.locked(vault: $vault)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Locked &&
            (identical(other.vault, vault) || other.vault == vault));
  }

  @override
  int get hashCode => Object.hash(runtimeType, vault);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LockedCopyWith<_$_Locked> get copyWith =>
      __$$_LockedCopyWithImpl<_$_Locked>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(int errorCount) opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)
        unlocked,
  }) {
    return locked(vault);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function(int errorCount)? opening,
    TResult? Function(VaultFile vault)? locked,
    TResult? Function(VaultFile vault)? unlocking,
    TResult? Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
  }) {
    return locked?.call(vault);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(int errorCount)? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
    required TResult orElse(),
  }) {
    if (locked != null) {
      return locked(vault);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) {
    return locked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_Opening value)? opening,
    TResult? Function(_Locked value)? locked,
    TResult? Function(_Unlocking value)? unlocking,
    TResult? Function(_Unlocked value)? unlocked,
  }) {
    return locked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) {
    if (locked != null) {
      return locked(this);
    }
    return orElse();
  }
}

abstract class _Locked implements VaultState {
  const factory _Locked(final VaultFile vault) = _$_Locked;

  VaultFile get vault;
  @JsonKey(ignore: true)
  _$$_LockedCopyWith<_$_Locked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UnlockingCopyWith<$Res> {
  factory _$$_UnlockingCopyWith(
          _$_Unlocking value, $Res Function(_$_Unlocking) then) =
      __$$_UnlockingCopyWithImpl<$Res>;
  @useResult
  $Res call({VaultFile vault});

  $VaultFileCopyWith<$Res> get vault;
}

/// @nodoc
class __$$_UnlockingCopyWithImpl<$Res>
    extends _$VaultStateCopyWithImpl<$Res, _$_Unlocking>
    implements _$$_UnlockingCopyWith<$Res> {
  __$$_UnlockingCopyWithImpl(
      _$_Unlocking _value, $Res Function(_$_Unlocking) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vault = null,
  }) {
    return _then(_$_Unlocking(
      null == vault
          ? _value.vault
          : vault // ignore: cast_nullable_to_non_nullable
              as VaultFile,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $VaultFileCopyWith<$Res> get vault {
    return $VaultFileCopyWith<$Res>(_value.vault, (value) {
      return _then(_value.copyWith(vault: value));
    });
  }
}

/// @nodoc

class _$_Unlocking implements _Unlocking {
  const _$_Unlocking(this.vault);

  @override
  final VaultFile vault;

  @override
  String toString() {
    return 'VaultState.unlocking(vault: $vault)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Unlocking &&
            (identical(other.vault, vault) || other.vault == vault));
  }

  @override
  int get hashCode => Object.hash(runtimeType, vault);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UnlockingCopyWith<_$_Unlocking> get copyWith =>
      __$$_UnlockingCopyWithImpl<_$_Unlocking>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(int errorCount) opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)
        unlocked,
  }) {
    return unlocking(vault);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function(int errorCount)? opening,
    TResult? Function(VaultFile vault)? locked,
    TResult? Function(VaultFile vault)? unlocking,
    TResult? Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
  }) {
    return unlocking?.call(vault);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(int errorCount)? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
    required TResult orElse(),
  }) {
    if (unlocking != null) {
      return unlocking(vault);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) {
    return unlocking(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_Opening value)? opening,
    TResult? Function(_Locked value)? locked,
    TResult? Function(_Unlocking value)? unlocking,
    TResult? Function(_Unlocked value)? unlocked,
  }) {
    return unlocking?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) {
    if (unlocking != null) {
      return unlocking(this);
    }
    return orElse();
  }
}

abstract class _Unlocking implements VaultState {
  const factory _Unlocking(final VaultFile vault) = _$_Unlocking;

  VaultFile get vault;
  @JsonKey(ignore: true)
  _$$_UnlockingCopyWith<_$_Unlocking> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UnlockedCopyWith<$Res> {
  factory _$$_UnlockedCopyWith(
          _$_Unlocked value, $Res Function(_$_Unlocked) then) =
      __$$_UnlockedCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {VaultFile vault,
      List<String>? selectedGroup,
      List<String>? selectedItem,
      bool viewingSelectedItem,
      Key? masterKey,
      int errorCounts});

  $VaultFileCopyWith<$Res> get vault;
}

/// @nodoc
class __$$_UnlockedCopyWithImpl<$Res>
    extends _$VaultStateCopyWithImpl<$Res, _$_Unlocked>
    implements _$$_UnlockedCopyWith<$Res> {
  __$$_UnlockedCopyWithImpl(
      _$_Unlocked _value, $Res Function(_$_Unlocked) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vault = null,
    Object? selectedGroup = freezed,
    Object? selectedItem = freezed,
    Object? viewingSelectedItem = null,
    Object? masterKey = freezed,
    Object? errorCounts = null,
  }) {
    return _then(_$_Unlocked(
      vault: null == vault
          ? _value.vault
          : vault // ignore: cast_nullable_to_non_nullable
              as VaultFile,
      selectedGroup: freezed == selectedGroup
          ? _value._selectedGroup
          : selectedGroup // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      selectedItem: freezed == selectedItem
          ? _value._selectedItem
          : selectedItem // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      viewingSelectedItem: null == viewingSelectedItem
          ? _value.viewingSelectedItem
          : viewingSelectedItem // ignore: cast_nullable_to_non_nullable
              as bool,
      masterKey: freezed == masterKey
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as Key?,
      errorCounts: null == errorCounts
          ? _value.errorCounts
          : errorCounts // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $VaultFileCopyWith<$Res> get vault {
    return $VaultFileCopyWith<$Res>(_value.vault, (value) {
      return _then(_value.copyWith(vault: value));
    });
  }
}

/// @nodoc

class _$_Unlocked implements _Unlocked {
  const _$_Unlocked(
      {required this.vault,
      final List<String>? selectedGroup,
      final List<String>? selectedItem,
      this.viewingSelectedItem = false,
      this.masterKey,
      this.errorCounts = 0})
      : _selectedGroup = selectedGroup,
        _selectedItem = selectedItem;

  @override
  final VaultFile vault;
  final List<String>? _selectedGroup;
  @override
  List<String>? get selectedGroup {
    final value = _selectedGroup;
    if (value == null) return null;
    if (_selectedGroup is EqualUnmodifiableListView) return _selectedGroup;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _selectedItem;
  @override
  List<String>? get selectedItem {
    final value = _selectedItem;
    if (value == null) return null;
    if (_selectedItem is EqualUnmodifiableListView) return _selectedItem;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey()
  final bool viewingSelectedItem;
  @override
  final Key? masterKey;
  @override
  @JsonKey()
  final int errorCounts;

  @override
  String toString() {
    return 'VaultState.unlocked(vault: $vault, selectedGroup: $selectedGroup, selectedItem: $selectedItem, viewingSelectedItem: $viewingSelectedItem, masterKey: $masterKey, errorCounts: $errorCounts)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Unlocked &&
            (identical(other.vault, vault) || other.vault == vault) &&
            const DeepCollectionEquality()
                .equals(other._selectedGroup, _selectedGroup) &&
            const DeepCollectionEquality()
                .equals(other._selectedItem, _selectedItem) &&
            (identical(other.viewingSelectedItem, viewingSelectedItem) ||
                other.viewingSelectedItem == viewingSelectedItem) &&
            (identical(other.masterKey, masterKey) ||
                other.masterKey == masterKey) &&
            (identical(other.errorCounts, errorCounts) ||
                other.errorCounts == errorCounts));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      vault,
      const DeepCollectionEquality().hash(_selectedGroup),
      const DeepCollectionEquality().hash(_selectedItem),
      viewingSelectedItem,
      masterKey,
      errorCounts);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UnlockedCopyWith<_$_Unlocked> get copyWith =>
      __$$_UnlockedCopyWithImpl<_$_Unlocked>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(int errorCount) opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)
        unlocked,
  }) {
    return unlocked(vault, selectedGroup, selectedItem, viewingSelectedItem,
        masterKey, errorCounts);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function(int errorCount)? opening,
    TResult? Function(VaultFile vault)? locked,
    TResult? Function(VaultFile vault)? unlocking,
    TResult? Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
  }) {
    return unlocked?.call(vault, selectedGroup, selectedItem,
        viewingSelectedItem, masterKey, errorCounts);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(int errorCount)? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey,
            int errorCounts)?
        unlocked,
    required TResult orElse(),
  }) {
    if (unlocked != null) {
      return unlocked(vault, selectedGroup, selectedItem, viewingSelectedItem,
          masterKey, errorCounts);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) {
    return unlocked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_Opening value)? opening,
    TResult? Function(_Locked value)? locked,
    TResult? Function(_Unlocking value)? unlocking,
    TResult? Function(_Unlocked value)? unlocked,
  }) {
    return unlocked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) {
    if (unlocked != null) {
      return unlocked(this);
    }
    return orElse();
  }
}

abstract class _Unlocked implements VaultState {
  const factory _Unlocked(
      {required final VaultFile vault,
      final List<String>? selectedGroup,
      final List<String>? selectedItem,
      final bool viewingSelectedItem,
      final Key? masterKey,
      final int errorCounts}) = _$_Unlocked;

  VaultFile get vault;
  List<String>? get selectedGroup;
  List<String>? get selectedItem;
  bool get viewingSelectedItem;
  Key? get masterKey;
  int get errorCounts;
  @JsonKey(ignore: true)
  _$$_UnlockedCopyWith<_$_Unlocked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$VaultEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url, BuildContext context) opened,
    required TResult Function(Key masterKey, BuildContext context) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(VaultUrl url, BuildContext context)? opened,
    TResult? Function(Key masterKey, BuildContext context)? unlocked,
    TResult? Function(Key? masterKey)? masterKeyChanged,
    TResult? Function(List<String>? path, bool deselect)? groupSelected,
    TResult? Function(List<String>? path, bool deselect)? itemSelected,
    TResult? Function()? selectedItemViewToggled,
    TResult? Function(VaultFile newVault, Key masterKey)? updated,
    TResult? Function()? locked,
    TResult? Function()? closed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url, BuildContext context)? opened,
    TResult Function(Key masterKey, BuildContext context)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenedEvent value)? opened,
    TResult? Function(UnlockedEvent value)? unlocked,
    TResult? Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult? Function(GroupSelectedEvent value)? groupSelected,
    TResult? Function(ItemSelectedEvent value)? itemSelected,
    TResult? Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult? Function(UpdatedEvent value)? updated,
    TResult? Function(LockedEvent value)? locked,
    TResult? Function(ClosedEvent value)? closed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VaultEventCopyWith<$Res> {
  factory $VaultEventCopyWith(
          VaultEvent value, $Res Function(VaultEvent) then) =
      _$VaultEventCopyWithImpl<$Res, VaultEvent>;
}

/// @nodoc
class _$VaultEventCopyWithImpl<$Res, $Val extends VaultEvent>
    implements $VaultEventCopyWith<$Res> {
  _$VaultEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$OpenedEventCopyWith<$Res> {
  factory _$$OpenedEventCopyWith(
          _$OpenedEvent value, $Res Function(_$OpenedEvent) then) =
      __$$OpenedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({VaultUrl url, BuildContext context});

  $VaultUrlCopyWith<$Res> get url;
}

/// @nodoc
class __$$OpenedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res, _$OpenedEvent>
    implements _$$OpenedEventCopyWith<$Res> {
  __$$OpenedEventCopyWithImpl(
      _$OpenedEvent _value, $Res Function(_$OpenedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? context = null,
  }) {
    return _then(_$OpenedEvent(
      null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as VaultUrl,
      null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $VaultUrlCopyWith<$Res> get url {
    return $VaultUrlCopyWith<$Res>(_value.url, (value) {
      return _then(_value.copyWith(url: value));
    });
  }
}

/// @nodoc

class _$OpenedEvent implements OpenedEvent {
  const _$OpenedEvent(this.url, this.context);

  @override
  final VaultUrl url;
  @override
  final BuildContext context;

  @override
  String toString() {
    return 'VaultEvent.opened(url: $url, context: $context)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenedEvent &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.context, context) || other.context == context));
  }

  @override
  int get hashCode => Object.hash(runtimeType, url, context);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OpenedEventCopyWith<_$OpenedEvent> get copyWith =>
      __$$OpenedEventCopyWithImpl<_$OpenedEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url, BuildContext context) opened,
    required TResult Function(Key masterKey, BuildContext context) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return opened(url, context);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(VaultUrl url, BuildContext context)? opened,
    TResult? Function(Key masterKey, BuildContext context)? unlocked,
    TResult? Function(Key? masterKey)? masterKeyChanged,
    TResult? Function(List<String>? path, bool deselect)? groupSelected,
    TResult? Function(List<String>? path, bool deselect)? itemSelected,
    TResult? Function()? selectedItemViewToggled,
    TResult? Function(VaultFile newVault, Key masterKey)? updated,
    TResult? Function()? locked,
    TResult? Function()? closed,
  }) {
    return opened?.call(url, context);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url, BuildContext context)? opened,
    TResult Function(Key masterKey, BuildContext context)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (opened != null) {
      return opened(url, context);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return opened(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenedEvent value)? opened,
    TResult? Function(UnlockedEvent value)? unlocked,
    TResult? Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult? Function(GroupSelectedEvent value)? groupSelected,
    TResult? Function(ItemSelectedEvent value)? itemSelected,
    TResult? Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult? Function(UpdatedEvent value)? updated,
    TResult? Function(LockedEvent value)? locked,
    TResult? Function(ClosedEvent value)? closed,
  }) {
    return opened?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (opened != null) {
      return opened(this);
    }
    return orElse();
  }
}

abstract class OpenedEvent implements VaultEvent {
  const factory OpenedEvent(final VaultUrl url, final BuildContext context) =
      _$OpenedEvent;

  VaultUrl get url;
  BuildContext get context;
  @JsonKey(ignore: true)
  _$$OpenedEventCopyWith<_$OpenedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnlockedEventCopyWith<$Res> {
  factory _$$UnlockedEventCopyWith(
          _$UnlockedEvent value, $Res Function(_$UnlockedEvent) then) =
      __$$UnlockedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({Key masterKey, BuildContext context});
}

/// @nodoc
class __$$UnlockedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res, _$UnlockedEvent>
    implements _$$UnlockedEventCopyWith<$Res> {
  __$$UnlockedEventCopyWithImpl(
      _$UnlockedEvent _value, $Res Function(_$UnlockedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? masterKey = null,
    Object? context = null,
  }) {
    return _then(_$UnlockedEvent(
      null == masterKey
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as Key,
      null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$UnlockedEvent implements UnlockedEvent {
  const _$UnlockedEvent(this.masterKey, this.context);

  @override
  final Key masterKey;
  @override
  final BuildContext context;

  @override
  String toString() {
    return 'VaultEvent.unlocked(masterKey: $masterKey, context: $context)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnlockedEvent &&
            (identical(other.masterKey, masterKey) ||
                other.masterKey == masterKey) &&
            (identical(other.context, context) || other.context == context));
  }

  @override
  int get hashCode => Object.hash(runtimeType, masterKey, context);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnlockedEventCopyWith<_$UnlockedEvent> get copyWith =>
      __$$UnlockedEventCopyWithImpl<_$UnlockedEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url, BuildContext context) opened,
    required TResult Function(Key masterKey, BuildContext context) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return unlocked(masterKey, context);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(VaultUrl url, BuildContext context)? opened,
    TResult? Function(Key masterKey, BuildContext context)? unlocked,
    TResult? Function(Key? masterKey)? masterKeyChanged,
    TResult? Function(List<String>? path, bool deselect)? groupSelected,
    TResult? Function(List<String>? path, bool deselect)? itemSelected,
    TResult? Function()? selectedItemViewToggled,
    TResult? Function(VaultFile newVault, Key masterKey)? updated,
    TResult? Function()? locked,
    TResult? Function()? closed,
  }) {
    return unlocked?.call(masterKey, context);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url, BuildContext context)? opened,
    TResult Function(Key masterKey, BuildContext context)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (unlocked != null) {
      return unlocked(masterKey, context);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return unlocked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenedEvent value)? opened,
    TResult? Function(UnlockedEvent value)? unlocked,
    TResult? Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult? Function(GroupSelectedEvent value)? groupSelected,
    TResult? Function(ItemSelectedEvent value)? itemSelected,
    TResult? Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult? Function(UpdatedEvent value)? updated,
    TResult? Function(LockedEvent value)? locked,
    TResult? Function(ClosedEvent value)? closed,
  }) {
    return unlocked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (unlocked != null) {
      return unlocked(this);
    }
    return orElse();
  }
}

abstract class UnlockedEvent implements VaultEvent {
  const factory UnlockedEvent(final Key masterKey, final BuildContext context) =
      _$UnlockedEvent;

  Key get masterKey;
  BuildContext get context;
  @JsonKey(ignore: true)
  _$$UnlockedEventCopyWith<_$UnlockedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MasterKeyChangedEventCopyWith<$Res> {
  factory _$$MasterKeyChangedEventCopyWith(_$MasterKeyChangedEvent value,
          $Res Function(_$MasterKeyChangedEvent) then) =
      __$$MasterKeyChangedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({Key? masterKey});
}

/// @nodoc
class __$$MasterKeyChangedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res, _$MasterKeyChangedEvent>
    implements _$$MasterKeyChangedEventCopyWith<$Res> {
  __$$MasterKeyChangedEventCopyWithImpl(_$MasterKeyChangedEvent _value,
      $Res Function(_$MasterKeyChangedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? masterKey = freezed,
  }) {
    return _then(_$MasterKeyChangedEvent(
      freezed == masterKey
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as Key?,
    ));
  }
}

/// @nodoc

class _$MasterKeyChangedEvent implements MasterKeyChangedEvent {
  const _$MasterKeyChangedEvent(this.masterKey);

  @override
  final Key? masterKey;

  @override
  String toString() {
    return 'VaultEvent.masterKeyChanged(masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MasterKeyChangedEvent &&
            (identical(other.masterKey, masterKey) ||
                other.masterKey == masterKey));
  }

  @override
  int get hashCode => Object.hash(runtimeType, masterKey);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MasterKeyChangedEventCopyWith<_$MasterKeyChangedEvent> get copyWith =>
      __$$MasterKeyChangedEventCopyWithImpl<_$MasterKeyChangedEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url, BuildContext context) opened,
    required TResult Function(Key masterKey, BuildContext context) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return masterKeyChanged(masterKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(VaultUrl url, BuildContext context)? opened,
    TResult? Function(Key masterKey, BuildContext context)? unlocked,
    TResult? Function(Key? masterKey)? masterKeyChanged,
    TResult? Function(List<String>? path, bool deselect)? groupSelected,
    TResult? Function(List<String>? path, bool deselect)? itemSelected,
    TResult? Function()? selectedItemViewToggled,
    TResult? Function(VaultFile newVault, Key masterKey)? updated,
    TResult? Function()? locked,
    TResult? Function()? closed,
  }) {
    return masterKeyChanged?.call(masterKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url, BuildContext context)? opened,
    TResult Function(Key masterKey, BuildContext context)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (masterKeyChanged != null) {
      return masterKeyChanged(masterKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return masterKeyChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenedEvent value)? opened,
    TResult? Function(UnlockedEvent value)? unlocked,
    TResult? Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult? Function(GroupSelectedEvent value)? groupSelected,
    TResult? Function(ItemSelectedEvent value)? itemSelected,
    TResult? Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult? Function(UpdatedEvent value)? updated,
    TResult? Function(LockedEvent value)? locked,
    TResult? Function(ClosedEvent value)? closed,
  }) {
    return masterKeyChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (masterKeyChanged != null) {
      return masterKeyChanged(this);
    }
    return orElse();
  }
}

abstract class MasterKeyChangedEvent implements VaultEvent {
  const factory MasterKeyChangedEvent(final Key? masterKey) =
      _$MasterKeyChangedEvent;

  Key? get masterKey;
  @JsonKey(ignore: true)
  _$$MasterKeyChangedEventCopyWith<_$MasterKeyChangedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GroupSelectedEventCopyWith<$Res> {
  factory _$$GroupSelectedEventCopyWith(_$GroupSelectedEvent value,
          $Res Function(_$GroupSelectedEvent) then) =
      __$$GroupSelectedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String>? path, bool deselect});
}

/// @nodoc
class __$$GroupSelectedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res, _$GroupSelectedEvent>
    implements _$$GroupSelectedEventCopyWith<$Res> {
  __$$GroupSelectedEventCopyWithImpl(
      _$GroupSelectedEvent _value, $Res Function(_$GroupSelectedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = freezed,
    Object? deselect = null,
  }) {
    return _then(_$GroupSelectedEvent(
      freezed == path
          ? _value._path
          : path // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      null == deselect
          ? _value.deselect
          : deselect // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$GroupSelectedEvent implements GroupSelectedEvent {
  const _$GroupSelectedEvent(final List<String>? path, this.deselect)
      : _path = path;

  final List<String>? _path;
  @override
  List<String>? get path {
    final value = _path;
    if (value == null) return null;
    if (_path is EqualUnmodifiableListView) return _path;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final bool deselect;

  @override
  String toString() {
    return 'VaultEvent.groupSelected(path: $path, deselect: $deselect)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GroupSelectedEvent &&
            const DeepCollectionEquality().equals(other._path, _path) &&
            (identical(other.deselect, deselect) ||
                other.deselect == deselect));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_path), deselect);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GroupSelectedEventCopyWith<_$GroupSelectedEvent> get copyWith =>
      __$$GroupSelectedEventCopyWithImpl<_$GroupSelectedEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url, BuildContext context) opened,
    required TResult Function(Key masterKey, BuildContext context) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return groupSelected(path, deselect);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(VaultUrl url, BuildContext context)? opened,
    TResult? Function(Key masterKey, BuildContext context)? unlocked,
    TResult? Function(Key? masterKey)? masterKeyChanged,
    TResult? Function(List<String>? path, bool deselect)? groupSelected,
    TResult? Function(List<String>? path, bool deselect)? itemSelected,
    TResult? Function()? selectedItemViewToggled,
    TResult? Function(VaultFile newVault, Key masterKey)? updated,
    TResult? Function()? locked,
    TResult? Function()? closed,
  }) {
    return groupSelected?.call(path, deselect);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url, BuildContext context)? opened,
    TResult Function(Key masterKey, BuildContext context)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (groupSelected != null) {
      return groupSelected(path, deselect);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return groupSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenedEvent value)? opened,
    TResult? Function(UnlockedEvent value)? unlocked,
    TResult? Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult? Function(GroupSelectedEvent value)? groupSelected,
    TResult? Function(ItemSelectedEvent value)? itemSelected,
    TResult? Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult? Function(UpdatedEvent value)? updated,
    TResult? Function(LockedEvent value)? locked,
    TResult? Function(ClosedEvent value)? closed,
  }) {
    return groupSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (groupSelected != null) {
      return groupSelected(this);
    }
    return orElse();
  }
}

abstract class GroupSelectedEvent implements VaultEvent {
  const factory GroupSelectedEvent(
      final List<String>? path, final bool deselect) = _$GroupSelectedEvent;

  List<String>? get path;
  bool get deselect;
  @JsonKey(ignore: true)
  _$$GroupSelectedEventCopyWith<_$GroupSelectedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ItemSelectedEventCopyWith<$Res> {
  factory _$$ItemSelectedEventCopyWith(
          _$ItemSelectedEvent value, $Res Function(_$ItemSelectedEvent) then) =
      __$$ItemSelectedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String>? path, bool deselect});
}

/// @nodoc
class __$$ItemSelectedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res, _$ItemSelectedEvent>
    implements _$$ItemSelectedEventCopyWith<$Res> {
  __$$ItemSelectedEventCopyWithImpl(
      _$ItemSelectedEvent _value, $Res Function(_$ItemSelectedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = freezed,
    Object? deselect = null,
  }) {
    return _then(_$ItemSelectedEvent(
      freezed == path
          ? _value._path
          : path // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      null == deselect
          ? _value.deselect
          : deselect // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ItemSelectedEvent implements ItemSelectedEvent {
  const _$ItemSelectedEvent(final List<String>? path, this.deselect)
      : _path = path;

  final List<String>? _path;
  @override
  List<String>? get path {
    final value = _path;
    if (value == null) return null;
    if (_path is EqualUnmodifiableListView) return _path;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final bool deselect;

  @override
  String toString() {
    return 'VaultEvent.itemSelected(path: $path, deselect: $deselect)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ItemSelectedEvent &&
            const DeepCollectionEquality().equals(other._path, _path) &&
            (identical(other.deselect, deselect) ||
                other.deselect == deselect));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_path), deselect);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ItemSelectedEventCopyWith<_$ItemSelectedEvent> get copyWith =>
      __$$ItemSelectedEventCopyWithImpl<_$ItemSelectedEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url, BuildContext context) opened,
    required TResult Function(Key masterKey, BuildContext context) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return itemSelected(path, deselect);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(VaultUrl url, BuildContext context)? opened,
    TResult? Function(Key masterKey, BuildContext context)? unlocked,
    TResult? Function(Key? masterKey)? masterKeyChanged,
    TResult? Function(List<String>? path, bool deselect)? groupSelected,
    TResult? Function(List<String>? path, bool deselect)? itemSelected,
    TResult? Function()? selectedItemViewToggled,
    TResult? Function(VaultFile newVault, Key masterKey)? updated,
    TResult? Function()? locked,
    TResult? Function()? closed,
  }) {
    return itemSelected?.call(path, deselect);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url, BuildContext context)? opened,
    TResult Function(Key masterKey, BuildContext context)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (itemSelected != null) {
      return itemSelected(path, deselect);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return itemSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenedEvent value)? opened,
    TResult? Function(UnlockedEvent value)? unlocked,
    TResult? Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult? Function(GroupSelectedEvent value)? groupSelected,
    TResult? Function(ItemSelectedEvent value)? itemSelected,
    TResult? Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult? Function(UpdatedEvent value)? updated,
    TResult? Function(LockedEvent value)? locked,
    TResult? Function(ClosedEvent value)? closed,
  }) {
    return itemSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (itemSelected != null) {
      return itemSelected(this);
    }
    return orElse();
  }
}

abstract class ItemSelectedEvent implements VaultEvent {
  const factory ItemSelectedEvent(
      final List<String>? path, final bool deselect) = _$ItemSelectedEvent;

  List<String>? get path;
  bool get deselect;
  @JsonKey(ignore: true)
  _$$ItemSelectedEventCopyWith<_$ItemSelectedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SelectedItemViewToggledEventCopyWith<$Res> {
  factory _$$SelectedItemViewToggledEventCopyWith(
          _$SelectedItemViewToggledEvent value,
          $Res Function(_$SelectedItemViewToggledEvent) then) =
      __$$SelectedItemViewToggledEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SelectedItemViewToggledEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res, _$SelectedItemViewToggledEvent>
    implements _$$SelectedItemViewToggledEventCopyWith<$Res> {
  __$$SelectedItemViewToggledEventCopyWithImpl(
      _$SelectedItemViewToggledEvent _value,
      $Res Function(_$SelectedItemViewToggledEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SelectedItemViewToggledEvent implements SelectedItemViewToggledEvent {
  const _$SelectedItemViewToggledEvent();

  @override
  String toString() {
    return 'VaultEvent.selectedItemViewToggled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectedItemViewToggledEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url, BuildContext context) opened,
    required TResult Function(Key masterKey, BuildContext context) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return selectedItemViewToggled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(VaultUrl url, BuildContext context)? opened,
    TResult? Function(Key masterKey, BuildContext context)? unlocked,
    TResult? Function(Key? masterKey)? masterKeyChanged,
    TResult? Function(List<String>? path, bool deselect)? groupSelected,
    TResult? Function(List<String>? path, bool deselect)? itemSelected,
    TResult? Function()? selectedItemViewToggled,
    TResult? Function(VaultFile newVault, Key masterKey)? updated,
    TResult? Function()? locked,
    TResult? Function()? closed,
  }) {
    return selectedItemViewToggled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url, BuildContext context)? opened,
    TResult Function(Key masterKey, BuildContext context)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (selectedItemViewToggled != null) {
      return selectedItemViewToggled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return selectedItemViewToggled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenedEvent value)? opened,
    TResult? Function(UnlockedEvent value)? unlocked,
    TResult? Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult? Function(GroupSelectedEvent value)? groupSelected,
    TResult? Function(ItemSelectedEvent value)? itemSelected,
    TResult? Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult? Function(UpdatedEvent value)? updated,
    TResult? Function(LockedEvent value)? locked,
    TResult? Function(ClosedEvent value)? closed,
  }) {
    return selectedItemViewToggled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (selectedItemViewToggled != null) {
      return selectedItemViewToggled(this);
    }
    return orElse();
  }
}

abstract class SelectedItemViewToggledEvent implements VaultEvent {
  const factory SelectedItemViewToggledEvent() = _$SelectedItemViewToggledEvent;
}

/// @nodoc
abstract class _$$UpdatedEventCopyWith<$Res> {
  factory _$$UpdatedEventCopyWith(
          _$UpdatedEvent value, $Res Function(_$UpdatedEvent) then) =
      __$$UpdatedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({VaultFile newVault, Key masterKey});

  $VaultFileCopyWith<$Res> get newVault;
}

/// @nodoc
class __$$UpdatedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res, _$UpdatedEvent>
    implements _$$UpdatedEventCopyWith<$Res> {
  __$$UpdatedEventCopyWithImpl(
      _$UpdatedEvent _value, $Res Function(_$UpdatedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? newVault = null,
    Object? masterKey = null,
  }) {
    return _then(_$UpdatedEvent(
      null == newVault
          ? _value.newVault
          : newVault // ignore: cast_nullable_to_non_nullable
              as VaultFile,
      null == masterKey
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as Key,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $VaultFileCopyWith<$Res> get newVault {
    return $VaultFileCopyWith<$Res>(_value.newVault, (value) {
      return _then(_value.copyWith(newVault: value));
    });
  }
}

/// @nodoc

class _$UpdatedEvent implements UpdatedEvent {
  const _$UpdatedEvent(this.newVault, this.masterKey);

  @override
  final VaultFile newVault;
  @override
  final Key masterKey;

  @override
  String toString() {
    return 'VaultEvent.updated(newVault: $newVault, masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdatedEvent &&
            (identical(other.newVault, newVault) ||
                other.newVault == newVault) &&
            (identical(other.masterKey, masterKey) ||
                other.masterKey == masterKey));
  }

  @override
  int get hashCode => Object.hash(runtimeType, newVault, masterKey);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdatedEventCopyWith<_$UpdatedEvent> get copyWith =>
      __$$UpdatedEventCopyWithImpl<_$UpdatedEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url, BuildContext context) opened,
    required TResult Function(Key masterKey, BuildContext context) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return updated(newVault, masterKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(VaultUrl url, BuildContext context)? opened,
    TResult? Function(Key masterKey, BuildContext context)? unlocked,
    TResult? Function(Key? masterKey)? masterKeyChanged,
    TResult? Function(List<String>? path, bool deselect)? groupSelected,
    TResult? Function(List<String>? path, bool deselect)? itemSelected,
    TResult? Function()? selectedItemViewToggled,
    TResult? Function(VaultFile newVault, Key masterKey)? updated,
    TResult? Function()? locked,
    TResult? Function()? closed,
  }) {
    return updated?.call(newVault, masterKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url, BuildContext context)? opened,
    TResult Function(Key masterKey, BuildContext context)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (updated != null) {
      return updated(newVault, masterKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return updated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenedEvent value)? opened,
    TResult? Function(UnlockedEvent value)? unlocked,
    TResult? Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult? Function(GroupSelectedEvent value)? groupSelected,
    TResult? Function(ItemSelectedEvent value)? itemSelected,
    TResult? Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult? Function(UpdatedEvent value)? updated,
    TResult? Function(LockedEvent value)? locked,
    TResult? Function(ClosedEvent value)? closed,
  }) {
    return updated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (updated != null) {
      return updated(this);
    }
    return orElse();
  }
}

abstract class UpdatedEvent implements VaultEvent {
  const factory UpdatedEvent(final VaultFile newVault, final Key masterKey) =
      _$UpdatedEvent;

  VaultFile get newVault;
  Key get masterKey;
  @JsonKey(ignore: true)
  _$$UpdatedEventCopyWith<_$UpdatedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LockedEventCopyWith<$Res> {
  factory _$$LockedEventCopyWith(
          _$LockedEvent value, $Res Function(_$LockedEvent) then) =
      __$$LockedEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LockedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res, _$LockedEvent>
    implements _$$LockedEventCopyWith<$Res> {
  __$$LockedEventCopyWithImpl(
      _$LockedEvent _value, $Res Function(_$LockedEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LockedEvent implements LockedEvent {
  const _$LockedEvent();

  @override
  String toString() {
    return 'VaultEvent.locked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LockedEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url, BuildContext context) opened,
    required TResult Function(Key masterKey, BuildContext context) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return locked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(VaultUrl url, BuildContext context)? opened,
    TResult? Function(Key masterKey, BuildContext context)? unlocked,
    TResult? Function(Key? masterKey)? masterKeyChanged,
    TResult? Function(List<String>? path, bool deselect)? groupSelected,
    TResult? Function(List<String>? path, bool deselect)? itemSelected,
    TResult? Function()? selectedItemViewToggled,
    TResult? Function(VaultFile newVault, Key masterKey)? updated,
    TResult? Function()? locked,
    TResult? Function()? closed,
  }) {
    return locked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url, BuildContext context)? opened,
    TResult Function(Key masterKey, BuildContext context)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (locked != null) {
      return locked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return locked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenedEvent value)? opened,
    TResult? Function(UnlockedEvent value)? unlocked,
    TResult? Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult? Function(GroupSelectedEvent value)? groupSelected,
    TResult? Function(ItemSelectedEvent value)? itemSelected,
    TResult? Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult? Function(UpdatedEvent value)? updated,
    TResult? Function(LockedEvent value)? locked,
    TResult? Function(ClosedEvent value)? closed,
  }) {
    return locked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (locked != null) {
      return locked(this);
    }
    return orElse();
  }
}

abstract class LockedEvent implements VaultEvent {
  const factory LockedEvent() = _$LockedEvent;
}

/// @nodoc
abstract class _$$ClosedEventCopyWith<$Res> {
  factory _$$ClosedEventCopyWith(
          _$ClosedEvent value, $Res Function(_$ClosedEvent) then) =
      __$$ClosedEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res, _$ClosedEvent>
    implements _$$ClosedEventCopyWith<$Res> {
  __$$ClosedEventCopyWithImpl(
      _$ClosedEvent _value, $Res Function(_$ClosedEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosedEvent implements ClosedEvent {
  const _$ClosedEvent();

  @override
  String toString() {
    return 'VaultEvent.closed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ClosedEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url, BuildContext context) opened,
    required TResult Function(Key masterKey, BuildContext context) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return closed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(VaultUrl url, BuildContext context)? opened,
    TResult? Function(Key masterKey, BuildContext context)? unlocked,
    TResult? Function(Key? masterKey)? masterKeyChanged,
    TResult? Function(List<String>? path, bool deselect)? groupSelected,
    TResult? Function(List<String>? path, bool deselect)? itemSelected,
    TResult? Function()? selectedItemViewToggled,
    TResult? Function(VaultFile newVault, Key masterKey)? updated,
    TResult? Function()? locked,
    TResult? Function()? closed,
  }) {
    return closed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url, BuildContext context)? opened,
    TResult Function(Key masterKey, BuildContext context)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (closed != null) {
      return closed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return closed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenedEvent value)? opened,
    TResult? Function(UnlockedEvent value)? unlocked,
    TResult? Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult? Function(GroupSelectedEvent value)? groupSelected,
    TResult? Function(ItemSelectedEvent value)? itemSelected,
    TResult? Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult? Function(UpdatedEvent value)? updated,
    TResult? Function(LockedEvent value)? locked,
    TResult? Function(ClosedEvent value)? closed,
  }) {
    return closed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (closed != null) {
      return closed(this);
    }
    return orElse();
  }
}

abstract class ClosedEvent implements VaultEvent {
  const factory ClosedEvent() = _$ClosedEvent;
}
