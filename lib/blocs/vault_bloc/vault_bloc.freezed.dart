// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'vault_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$VaultState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)
        unlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VaultStateCopyWith<$Res> {
  factory $VaultStateCopyWith(
          VaultState value, $Res Function(VaultState) then) =
      _$VaultStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$VaultStateCopyWithImpl<$Res> implements $VaultStateCopyWith<$Res> {
  _$VaultStateCopyWithImpl(this._value, this._then);

  final VaultState _value;
  // ignore: unused_field
  final $Res Function(VaultState) _then;
}

/// @nodoc
abstract class _$$_NoneCopyWith<$Res> {
  factory _$$_NoneCopyWith(_$_None value, $Res Function(_$_None) then) =
      __$$_NoneCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NoneCopyWithImpl<$Res> extends _$VaultStateCopyWithImpl<$Res>
    implements _$$_NoneCopyWith<$Res> {
  __$$_NoneCopyWithImpl(_$_None _value, $Res Function(_$_None) _then)
      : super(_value, (v) => _then(v as _$_None));

  @override
  _$_None get _value => super._value as _$_None;
}

/// @nodoc

class _$_None implements _None {
  const _$_None();

  @override
  String toString() {
    return 'VaultState.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_None);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)
        unlocked,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class _None implements VaultState {
  const factory _None() = _$_None;
}

/// @nodoc
abstract class _$$_OpeningCopyWith<$Res> {
  factory _$$_OpeningCopyWith(
          _$_Opening value, $Res Function(_$_Opening) then) =
      __$$_OpeningCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_OpeningCopyWithImpl<$Res> extends _$VaultStateCopyWithImpl<$Res>
    implements _$$_OpeningCopyWith<$Res> {
  __$$_OpeningCopyWithImpl(_$_Opening _value, $Res Function(_$_Opening) _then)
      : super(_value, (v) => _then(v as _$_Opening));

  @override
  _$_Opening get _value => super._value as _$_Opening;
}

/// @nodoc

class _$_Opening implements _Opening {
  const _$_Opening();

  @override
  String toString() {
    return 'VaultState.opening()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Opening);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)
        unlocked,
  }) {
    return opening();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
  }) {
    return opening?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
    required TResult orElse(),
  }) {
    if (opening != null) {
      return opening();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) {
    return opening(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
  }) {
    return opening?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) {
    if (opening != null) {
      return opening(this);
    }
    return orElse();
  }
}

abstract class _Opening implements VaultState {
  const factory _Opening() = _$_Opening;
}

/// @nodoc
abstract class _$$_LockedCopyWith<$Res> {
  factory _$$_LockedCopyWith(_$_Locked value, $Res Function(_$_Locked) then) =
      __$$_LockedCopyWithImpl<$Res>;
  $Res call({VaultFile vault});

  $VaultFileCopyWith<$Res> get vault;
}

/// @nodoc
class __$$_LockedCopyWithImpl<$Res> extends _$VaultStateCopyWithImpl<$Res>
    implements _$$_LockedCopyWith<$Res> {
  __$$_LockedCopyWithImpl(_$_Locked _value, $Res Function(_$_Locked) _then)
      : super(_value, (v) => _then(v as _$_Locked));

  @override
  _$_Locked get _value => super._value as _$_Locked;

  @override
  $Res call({
    Object? vault = freezed,
  }) {
    return _then(_$_Locked(
      vault == freezed
          ? _value.vault
          : vault // ignore: cast_nullable_to_non_nullable
              as VaultFile,
    ));
  }

  @override
  $VaultFileCopyWith<$Res> get vault {
    return $VaultFileCopyWith<$Res>(_value.vault, (value) {
      return _then(_value.copyWith(vault: value));
    });
  }
}

/// @nodoc

class _$_Locked implements _Locked {
  const _$_Locked(this.vault);

  @override
  final VaultFile vault;

  @override
  String toString() {
    return 'VaultState.locked(vault: $vault)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Locked &&
            const DeepCollectionEquality().equals(other.vault, vault));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(vault));

  @JsonKey(ignore: true)
  @override
  _$$_LockedCopyWith<_$_Locked> get copyWith =>
      __$$_LockedCopyWithImpl<_$_Locked>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)
        unlocked,
  }) {
    return locked(vault);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
  }) {
    return locked?.call(vault);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
    required TResult orElse(),
  }) {
    if (locked != null) {
      return locked(vault);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) {
    return locked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
  }) {
    return locked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) {
    if (locked != null) {
      return locked(this);
    }
    return orElse();
  }
}

abstract class _Locked implements VaultState {
  const factory _Locked(final VaultFile vault) = _$_Locked;

  VaultFile get vault;
  @JsonKey(ignore: true)
  _$$_LockedCopyWith<_$_Locked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UnlockingCopyWith<$Res> {
  factory _$$_UnlockingCopyWith(
          _$_Unlocking value, $Res Function(_$_Unlocking) then) =
      __$$_UnlockingCopyWithImpl<$Res>;
  $Res call({VaultFile vault});

  $VaultFileCopyWith<$Res> get vault;
}

/// @nodoc
class __$$_UnlockingCopyWithImpl<$Res> extends _$VaultStateCopyWithImpl<$Res>
    implements _$$_UnlockingCopyWith<$Res> {
  __$$_UnlockingCopyWithImpl(
      _$_Unlocking _value, $Res Function(_$_Unlocking) _then)
      : super(_value, (v) => _then(v as _$_Unlocking));

  @override
  _$_Unlocking get _value => super._value as _$_Unlocking;

  @override
  $Res call({
    Object? vault = freezed,
  }) {
    return _then(_$_Unlocking(
      vault == freezed
          ? _value.vault
          : vault // ignore: cast_nullable_to_non_nullable
              as VaultFile,
    ));
  }

  @override
  $VaultFileCopyWith<$Res> get vault {
    return $VaultFileCopyWith<$Res>(_value.vault, (value) {
      return _then(_value.copyWith(vault: value));
    });
  }
}

/// @nodoc

class _$_Unlocking implements _Unlocking {
  const _$_Unlocking(this.vault);

  @override
  final VaultFile vault;

  @override
  String toString() {
    return 'VaultState.unlocking(vault: $vault)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Unlocking &&
            const DeepCollectionEquality().equals(other.vault, vault));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(vault));

  @JsonKey(ignore: true)
  @override
  _$$_UnlockingCopyWith<_$_Unlocking> get copyWith =>
      __$$_UnlockingCopyWithImpl<_$_Unlocking>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)
        unlocked,
  }) {
    return unlocking(vault);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
  }) {
    return unlocking?.call(vault);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
    required TResult orElse(),
  }) {
    if (unlocking != null) {
      return unlocking(vault);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) {
    return unlocking(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
  }) {
    return unlocking?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) {
    if (unlocking != null) {
      return unlocking(this);
    }
    return orElse();
  }
}

abstract class _Unlocking implements VaultState {
  const factory _Unlocking(final VaultFile vault) = _$_Unlocking;

  VaultFile get vault;
  @JsonKey(ignore: true)
  _$$_UnlockingCopyWith<_$_Unlocking> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UnlockedCopyWith<$Res> {
  factory _$$_UnlockedCopyWith(
          _$_Unlocked value, $Res Function(_$_Unlocked) then) =
      __$$_UnlockedCopyWithImpl<$Res>;
  $Res call(
      {VaultFile vault,
      List<String>? selectedGroup,
      List<String>? selectedItem,
      bool viewingSelectedItem,
      Key? masterKey});

  $VaultFileCopyWith<$Res> get vault;
}

/// @nodoc
class __$$_UnlockedCopyWithImpl<$Res> extends _$VaultStateCopyWithImpl<$Res>
    implements _$$_UnlockedCopyWith<$Res> {
  __$$_UnlockedCopyWithImpl(
      _$_Unlocked _value, $Res Function(_$_Unlocked) _then)
      : super(_value, (v) => _then(v as _$_Unlocked));

  @override
  _$_Unlocked get _value => super._value as _$_Unlocked;

  @override
  $Res call({
    Object? vault = freezed,
    Object? selectedGroup = freezed,
    Object? selectedItem = freezed,
    Object? viewingSelectedItem = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(_$_Unlocked(
      vault: vault == freezed
          ? _value.vault
          : vault // ignore: cast_nullable_to_non_nullable
              as VaultFile,
      selectedGroup: selectedGroup == freezed
          ? _value._selectedGroup
          : selectedGroup // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      selectedItem: selectedItem == freezed
          ? _value._selectedItem
          : selectedItem // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      viewingSelectedItem: viewingSelectedItem == freezed
          ? _value.viewingSelectedItem
          : viewingSelectedItem // ignore: cast_nullable_to_non_nullable
              as bool,
      masterKey: masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as Key?,
    ));
  }

  @override
  $VaultFileCopyWith<$Res> get vault {
    return $VaultFileCopyWith<$Res>(_value.vault, (value) {
      return _then(_value.copyWith(vault: value));
    });
  }
}

/// @nodoc

class _$_Unlocked implements _Unlocked {
  const _$_Unlocked(
      {required this.vault,
      final List<String>? selectedGroup,
      final List<String>? selectedItem,
      this.viewingSelectedItem = false,
      this.masterKey})
      : _selectedGroup = selectedGroup,
        _selectedItem = selectedItem;

  @override
  final VaultFile vault;
  final List<String>? _selectedGroup;
  @override
  List<String>? get selectedGroup {
    final value = _selectedGroup;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _selectedItem;
  @override
  List<String>? get selectedItem {
    final value = _selectedItem;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey()
  final bool viewingSelectedItem;
  @override
  final Key? masterKey;

  @override
  String toString() {
    return 'VaultState.unlocked(vault: $vault, selectedGroup: $selectedGroup, selectedItem: $selectedItem, viewingSelectedItem: $viewingSelectedItem, masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Unlocked &&
            const DeepCollectionEquality().equals(other.vault, vault) &&
            const DeepCollectionEquality()
                .equals(other._selectedGroup, _selectedGroup) &&
            const DeepCollectionEquality()
                .equals(other._selectedItem, _selectedItem) &&
            const DeepCollectionEquality()
                .equals(other.viewingSelectedItem, viewingSelectedItem) &&
            const DeepCollectionEquality().equals(other.masterKey, masterKey));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(vault),
      const DeepCollectionEquality().hash(_selectedGroup),
      const DeepCollectionEquality().hash(_selectedItem),
      const DeepCollectionEquality().hash(viewingSelectedItem),
      const DeepCollectionEquality().hash(masterKey));

  @JsonKey(ignore: true)
  @override
  _$$_UnlockedCopyWith<_$_Unlocked> get copyWith =>
      __$$_UnlockedCopyWithImpl<_$_Unlocked>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() opening,
    required TResult Function(VaultFile vault) locked,
    required TResult Function(VaultFile vault) unlocking,
    required TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)
        unlocked,
  }) {
    return unlocked(
        vault, selectedGroup, selectedItem, viewingSelectedItem, masterKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
  }) {
    return unlocked?.call(
        vault, selectedGroup, selectedItem, viewingSelectedItem, masterKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? opening,
    TResult Function(VaultFile vault)? locked,
    TResult Function(VaultFile vault)? unlocking,
    TResult Function(
            VaultFile vault,
            List<String>? selectedGroup,
            List<String>? selectedItem,
            bool viewingSelectedItem,
            Key? masterKey)?
        unlocked,
    required TResult orElse(),
  }) {
    if (unlocked != null) {
      return unlocked(
          vault, selectedGroup, selectedItem, viewingSelectedItem, masterKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Locked value) locked,
    required TResult Function(_Unlocking value) unlocking,
    required TResult Function(_Unlocked value) unlocked,
  }) {
    return unlocked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
  }) {
    return unlocked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Opening value)? opening,
    TResult Function(_Locked value)? locked,
    TResult Function(_Unlocking value)? unlocking,
    TResult Function(_Unlocked value)? unlocked,
    required TResult orElse(),
  }) {
    if (unlocked != null) {
      return unlocked(this);
    }
    return orElse();
  }
}

abstract class _Unlocked implements VaultState {
  const factory _Unlocked(
      {required final VaultFile vault,
      final List<String>? selectedGroup,
      final List<String>? selectedItem,
      final bool viewingSelectedItem,
      final Key? masterKey}) = _$_Unlocked;

  VaultFile get vault;
  List<String>? get selectedGroup;
  List<String>? get selectedItem;
  bool get viewingSelectedItem;
  Key? get masterKey;
  @JsonKey(ignore: true)
  _$$_UnlockedCopyWith<_$_Unlocked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$VaultEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url) opened,
    required TResult Function(Key masterKey) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VaultEventCopyWith<$Res> {
  factory $VaultEventCopyWith(
          VaultEvent value, $Res Function(VaultEvent) then) =
      _$VaultEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$VaultEventCopyWithImpl<$Res> implements $VaultEventCopyWith<$Res> {
  _$VaultEventCopyWithImpl(this._value, this._then);

  final VaultEvent _value;
  // ignore: unused_field
  final $Res Function(VaultEvent) _then;
}

/// @nodoc
abstract class _$$OpenedEventCopyWith<$Res> {
  factory _$$OpenedEventCopyWith(
          _$OpenedEvent value, $Res Function(_$OpenedEvent) then) =
      __$$OpenedEventCopyWithImpl<$Res>;
  $Res call({VaultUrl url});

  $VaultUrlCopyWith<$Res> get url;
}

/// @nodoc
class __$$OpenedEventCopyWithImpl<$Res> extends _$VaultEventCopyWithImpl<$Res>
    implements _$$OpenedEventCopyWith<$Res> {
  __$$OpenedEventCopyWithImpl(
      _$OpenedEvent _value, $Res Function(_$OpenedEvent) _then)
      : super(_value, (v) => _then(v as _$OpenedEvent));

  @override
  _$OpenedEvent get _value => super._value as _$OpenedEvent;

  @override
  $Res call({
    Object? url = freezed,
  }) {
    return _then(_$OpenedEvent(
      url == freezed
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as VaultUrl,
    ));
  }

  @override
  $VaultUrlCopyWith<$Res> get url {
    return $VaultUrlCopyWith<$Res>(_value.url, (value) {
      return _then(_value.copyWith(url: value));
    });
  }
}

/// @nodoc

class _$OpenedEvent implements OpenedEvent {
  const _$OpenedEvent(this.url);

  @override
  final VaultUrl url;

  @override
  String toString() {
    return 'VaultEvent.opened(url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenedEvent &&
            const DeepCollectionEquality().equals(other.url, url));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(url));

  @JsonKey(ignore: true)
  @override
  _$$OpenedEventCopyWith<_$OpenedEvent> get copyWith =>
      __$$OpenedEventCopyWithImpl<_$OpenedEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url) opened,
    required TResult Function(Key masterKey) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return opened(url);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
  }) {
    return opened?.call(url);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (opened != null) {
      return opened(url);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return opened(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
  }) {
    return opened?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (opened != null) {
      return opened(this);
    }
    return orElse();
  }
}

abstract class OpenedEvent implements VaultEvent {
  const factory OpenedEvent(final VaultUrl url) = _$OpenedEvent;

  VaultUrl get url;
  @JsonKey(ignore: true)
  _$$OpenedEventCopyWith<_$OpenedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnlockedEventCopyWith<$Res> {
  factory _$$UnlockedEventCopyWith(
          _$UnlockedEvent value, $Res Function(_$UnlockedEvent) then) =
      __$$UnlockedEventCopyWithImpl<$Res>;
  $Res call({Key masterKey});
}

/// @nodoc
class __$$UnlockedEventCopyWithImpl<$Res> extends _$VaultEventCopyWithImpl<$Res>
    implements _$$UnlockedEventCopyWith<$Res> {
  __$$UnlockedEventCopyWithImpl(
      _$UnlockedEvent _value, $Res Function(_$UnlockedEvent) _then)
      : super(_value, (v) => _then(v as _$UnlockedEvent));

  @override
  _$UnlockedEvent get _value => super._value as _$UnlockedEvent;

  @override
  $Res call({
    Object? masterKey = freezed,
  }) {
    return _then(_$UnlockedEvent(
      masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as Key,
    ));
  }
}

/// @nodoc

class _$UnlockedEvent implements UnlockedEvent {
  const _$UnlockedEvent(this.masterKey);

  @override
  final Key masterKey;

  @override
  String toString() {
    return 'VaultEvent.unlocked(masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnlockedEvent &&
            const DeepCollectionEquality().equals(other.masterKey, masterKey));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(masterKey));

  @JsonKey(ignore: true)
  @override
  _$$UnlockedEventCopyWith<_$UnlockedEvent> get copyWith =>
      __$$UnlockedEventCopyWithImpl<_$UnlockedEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url) opened,
    required TResult Function(Key masterKey) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return unlocked(masterKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
  }) {
    return unlocked?.call(masterKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (unlocked != null) {
      return unlocked(masterKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return unlocked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
  }) {
    return unlocked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (unlocked != null) {
      return unlocked(this);
    }
    return orElse();
  }
}

abstract class UnlockedEvent implements VaultEvent {
  const factory UnlockedEvent(final Key masterKey) = _$UnlockedEvent;

  Key get masterKey;
  @JsonKey(ignore: true)
  _$$UnlockedEventCopyWith<_$UnlockedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MasterKeyChangedEventCopyWith<$Res> {
  factory _$$MasterKeyChangedEventCopyWith(_$MasterKeyChangedEvent value,
          $Res Function(_$MasterKeyChangedEvent) then) =
      __$$MasterKeyChangedEventCopyWithImpl<$Res>;
  $Res call({Key? masterKey});
}

/// @nodoc
class __$$MasterKeyChangedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res>
    implements _$$MasterKeyChangedEventCopyWith<$Res> {
  __$$MasterKeyChangedEventCopyWithImpl(_$MasterKeyChangedEvent _value,
      $Res Function(_$MasterKeyChangedEvent) _then)
      : super(_value, (v) => _then(v as _$MasterKeyChangedEvent));

  @override
  _$MasterKeyChangedEvent get _value => super._value as _$MasterKeyChangedEvent;

  @override
  $Res call({
    Object? masterKey = freezed,
  }) {
    return _then(_$MasterKeyChangedEvent(
      masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as Key?,
    ));
  }
}

/// @nodoc

class _$MasterKeyChangedEvent implements MasterKeyChangedEvent {
  const _$MasterKeyChangedEvent(this.masterKey);

  @override
  final Key? masterKey;

  @override
  String toString() {
    return 'VaultEvent.masterKeyChanged(masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MasterKeyChangedEvent &&
            const DeepCollectionEquality().equals(other.masterKey, masterKey));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(masterKey));

  @JsonKey(ignore: true)
  @override
  _$$MasterKeyChangedEventCopyWith<_$MasterKeyChangedEvent> get copyWith =>
      __$$MasterKeyChangedEventCopyWithImpl<_$MasterKeyChangedEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url) opened,
    required TResult Function(Key masterKey) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return masterKeyChanged(masterKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
  }) {
    return masterKeyChanged?.call(masterKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (masterKeyChanged != null) {
      return masterKeyChanged(masterKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return masterKeyChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
  }) {
    return masterKeyChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (masterKeyChanged != null) {
      return masterKeyChanged(this);
    }
    return orElse();
  }
}

abstract class MasterKeyChangedEvent implements VaultEvent {
  const factory MasterKeyChangedEvent(final Key? masterKey) =
      _$MasterKeyChangedEvent;

  Key? get masterKey;
  @JsonKey(ignore: true)
  _$$MasterKeyChangedEventCopyWith<_$MasterKeyChangedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GroupSelectedEventCopyWith<$Res> {
  factory _$$GroupSelectedEventCopyWith(_$GroupSelectedEvent value,
          $Res Function(_$GroupSelectedEvent) then) =
      __$$GroupSelectedEventCopyWithImpl<$Res>;
  $Res call({List<String>? path, bool deselect});
}

/// @nodoc
class __$$GroupSelectedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res>
    implements _$$GroupSelectedEventCopyWith<$Res> {
  __$$GroupSelectedEventCopyWithImpl(
      _$GroupSelectedEvent _value, $Res Function(_$GroupSelectedEvent) _then)
      : super(_value, (v) => _then(v as _$GroupSelectedEvent));

  @override
  _$GroupSelectedEvent get _value => super._value as _$GroupSelectedEvent;

  @override
  $Res call({
    Object? path = freezed,
    Object? deselect = freezed,
  }) {
    return _then(_$GroupSelectedEvent(
      path == freezed
          ? _value._path
          : path // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      deselect == freezed
          ? _value.deselect
          : deselect // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$GroupSelectedEvent implements GroupSelectedEvent {
  const _$GroupSelectedEvent(final List<String>? path, this.deselect)
      : _path = path;

  final List<String>? _path;
  @override
  List<String>? get path {
    final value = _path;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final bool deselect;

  @override
  String toString() {
    return 'VaultEvent.groupSelected(path: $path, deselect: $deselect)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GroupSelectedEvent &&
            const DeepCollectionEquality().equals(other._path, _path) &&
            const DeepCollectionEquality().equals(other.deselect, deselect));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_path),
      const DeepCollectionEquality().hash(deselect));

  @JsonKey(ignore: true)
  @override
  _$$GroupSelectedEventCopyWith<_$GroupSelectedEvent> get copyWith =>
      __$$GroupSelectedEventCopyWithImpl<_$GroupSelectedEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url) opened,
    required TResult Function(Key masterKey) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return groupSelected(path, deselect);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
  }) {
    return groupSelected?.call(path, deselect);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (groupSelected != null) {
      return groupSelected(path, deselect);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return groupSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
  }) {
    return groupSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (groupSelected != null) {
      return groupSelected(this);
    }
    return orElse();
  }
}

abstract class GroupSelectedEvent implements VaultEvent {
  const factory GroupSelectedEvent(
      final List<String>? path, final bool deselect) = _$GroupSelectedEvent;

  List<String>? get path;
  bool get deselect;
  @JsonKey(ignore: true)
  _$$GroupSelectedEventCopyWith<_$GroupSelectedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ItemSelectedEventCopyWith<$Res> {
  factory _$$ItemSelectedEventCopyWith(
          _$ItemSelectedEvent value, $Res Function(_$ItemSelectedEvent) then) =
      __$$ItemSelectedEventCopyWithImpl<$Res>;
  $Res call({List<String>? path, bool deselect});
}

/// @nodoc
class __$$ItemSelectedEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res>
    implements _$$ItemSelectedEventCopyWith<$Res> {
  __$$ItemSelectedEventCopyWithImpl(
      _$ItemSelectedEvent _value, $Res Function(_$ItemSelectedEvent) _then)
      : super(_value, (v) => _then(v as _$ItemSelectedEvent));

  @override
  _$ItemSelectedEvent get _value => super._value as _$ItemSelectedEvent;

  @override
  $Res call({
    Object? path = freezed,
    Object? deselect = freezed,
  }) {
    return _then(_$ItemSelectedEvent(
      path == freezed
          ? _value._path
          : path // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      deselect == freezed
          ? _value.deselect
          : deselect // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ItemSelectedEvent implements ItemSelectedEvent {
  const _$ItemSelectedEvent(final List<String>? path, this.deselect)
      : _path = path;

  final List<String>? _path;
  @override
  List<String>? get path {
    final value = _path;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final bool deselect;

  @override
  String toString() {
    return 'VaultEvent.itemSelected(path: $path, deselect: $deselect)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ItemSelectedEvent &&
            const DeepCollectionEquality().equals(other._path, _path) &&
            const DeepCollectionEquality().equals(other.deselect, deselect));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_path),
      const DeepCollectionEquality().hash(deselect));

  @JsonKey(ignore: true)
  @override
  _$$ItemSelectedEventCopyWith<_$ItemSelectedEvent> get copyWith =>
      __$$ItemSelectedEventCopyWithImpl<_$ItemSelectedEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url) opened,
    required TResult Function(Key masterKey) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return itemSelected(path, deselect);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
  }) {
    return itemSelected?.call(path, deselect);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (itemSelected != null) {
      return itemSelected(path, deselect);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return itemSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
  }) {
    return itemSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (itemSelected != null) {
      return itemSelected(this);
    }
    return orElse();
  }
}

abstract class ItemSelectedEvent implements VaultEvent {
  const factory ItemSelectedEvent(
      final List<String>? path, final bool deselect) = _$ItemSelectedEvent;

  List<String>? get path;
  bool get deselect;
  @JsonKey(ignore: true)
  _$$ItemSelectedEventCopyWith<_$ItemSelectedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SelectedItemViewToggledEventCopyWith<$Res> {
  factory _$$SelectedItemViewToggledEventCopyWith(
          _$SelectedItemViewToggledEvent value,
          $Res Function(_$SelectedItemViewToggledEvent) then) =
      __$$SelectedItemViewToggledEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SelectedItemViewToggledEventCopyWithImpl<$Res>
    extends _$VaultEventCopyWithImpl<$Res>
    implements _$$SelectedItemViewToggledEventCopyWith<$Res> {
  __$$SelectedItemViewToggledEventCopyWithImpl(
      _$SelectedItemViewToggledEvent _value,
      $Res Function(_$SelectedItemViewToggledEvent) _then)
      : super(_value, (v) => _then(v as _$SelectedItemViewToggledEvent));

  @override
  _$SelectedItemViewToggledEvent get _value =>
      super._value as _$SelectedItemViewToggledEvent;
}

/// @nodoc

class _$SelectedItemViewToggledEvent implements SelectedItemViewToggledEvent {
  const _$SelectedItemViewToggledEvent();

  @override
  String toString() {
    return 'VaultEvent.selectedItemViewToggled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectedItemViewToggledEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url) opened,
    required TResult Function(Key masterKey) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return selectedItemViewToggled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
  }) {
    return selectedItemViewToggled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (selectedItemViewToggled != null) {
      return selectedItemViewToggled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return selectedItemViewToggled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
  }) {
    return selectedItemViewToggled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (selectedItemViewToggled != null) {
      return selectedItemViewToggled(this);
    }
    return orElse();
  }
}

abstract class SelectedItemViewToggledEvent implements VaultEvent {
  const factory SelectedItemViewToggledEvent() = _$SelectedItemViewToggledEvent;
}

/// @nodoc
abstract class _$$UpdatedEventCopyWith<$Res> {
  factory _$$UpdatedEventCopyWith(
          _$UpdatedEvent value, $Res Function(_$UpdatedEvent) then) =
      __$$UpdatedEventCopyWithImpl<$Res>;
  $Res call({VaultFile newVault, Key masterKey});

  $VaultFileCopyWith<$Res> get newVault;
}

/// @nodoc
class __$$UpdatedEventCopyWithImpl<$Res> extends _$VaultEventCopyWithImpl<$Res>
    implements _$$UpdatedEventCopyWith<$Res> {
  __$$UpdatedEventCopyWithImpl(
      _$UpdatedEvent _value, $Res Function(_$UpdatedEvent) _then)
      : super(_value, (v) => _then(v as _$UpdatedEvent));

  @override
  _$UpdatedEvent get _value => super._value as _$UpdatedEvent;

  @override
  $Res call({
    Object? newVault = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(_$UpdatedEvent(
      newVault == freezed
          ? _value.newVault
          : newVault // ignore: cast_nullable_to_non_nullable
              as VaultFile,
      masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as Key,
    ));
  }

  @override
  $VaultFileCopyWith<$Res> get newVault {
    return $VaultFileCopyWith<$Res>(_value.newVault, (value) {
      return _then(_value.copyWith(newVault: value));
    });
  }
}

/// @nodoc

class _$UpdatedEvent implements UpdatedEvent {
  const _$UpdatedEvent(this.newVault, this.masterKey);

  @override
  final VaultFile newVault;
  @override
  final Key masterKey;

  @override
  String toString() {
    return 'VaultEvent.updated(newVault: $newVault, masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdatedEvent &&
            const DeepCollectionEquality().equals(other.newVault, newVault) &&
            const DeepCollectionEquality().equals(other.masterKey, masterKey));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(newVault),
      const DeepCollectionEquality().hash(masterKey));

  @JsonKey(ignore: true)
  @override
  _$$UpdatedEventCopyWith<_$UpdatedEvent> get copyWith =>
      __$$UpdatedEventCopyWithImpl<_$UpdatedEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url) opened,
    required TResult Function(Key masterKey) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return updated(newVault, masterKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
  }) {
    return updated?.call(newVault, masterKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (updated != null) {
      return updated(newVault, masterKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return updated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
  }) {
    return updated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (updated != null) {
      return updated(this);
    }
    return orElse();
  }
}

abstract class UpdatedEvent implements VaultEvent {
  const factory UpdatedEvent(final VaultFile newVault, final Key masterKey) =
      _$UpdatedEvent;

  VaultFile get newVault;
  Key get masterKey;
  @JsonKey(ignore: true)
  _$$UpdatedEventCopyWith<_$UpdatedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LockedEventCopyWith<$Res> {
  factory _$$LockedEventCopyWith(
          _$LockedEvent value, $Res Function(_$LockedEvent) then) =
      __$$LockedEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LockedEventCopyWithImpl<$Res> extends _$VaultEventCopyWithImpl<$Res>
    implements _$$LockedEventCopyWith<$Res> {
  __$$LockedEventCopyWithImpl(
      _$LockedEvent _value, $Res Function(_$LockedEvent) _then)
      : super(_value, (v) => _then(v as _$LockedEvent));

  @override
  _$LockedEvent get _value => super._value as _$LockedEvent;
}

/// @nodoc

class _$LockedEvent implements LockedEvent {
  const _$LockedEvent();

  @override
  String toString() {
    return 'VaultEvent.locked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LockedEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url) opened,
    required TResult Function(Key masterKey) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return locked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
  }) {
    return locked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (locked != null) {
      return locked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return locked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
  }) {
    return locked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (locked != null) {
      return locked(this);
    }
    return orElse();
  }
}

abstract class LockedEvent implements VaultEvent {
  const factory LockedEvent() = _$LockedEvent;
}

/// @nodoc
abstract class _$$ClosedEventCopyWith<$Res> {
  factory _$$ClosedEventCopyWith(
          _$ClosedEvent value, $Res Function(_$ClosedEvent) then) =
      __$$ClosedEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosedEventCopyWithImpl<$Res> extends _$VaultEventCopyWithImpl<$Res>
    implements _$$ClosedEventCopyWith<$Res> {
  __$$ClosedEventCopyWithImpl(
      _$ClosedEvent _value, $Res Function(_$ClosedEvent) _then)
      : super(_value, (v) => _then(v as _$ClosedEvent));

  @override
  _$ClosedEvent get _value => super._value as _$ClosedEvent;
}

/// @nodoc

class _$ClosedEvent implements ClosedEvent {
  const _$ClosedEvent();

  @override
  String toString() {
    return 'VaultEvent.closed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ClosedEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(VaultUrl url) opened,
    required TResult Function(Key masterKey) unlocked,
    required TResult Function(Key? masterKey) masterKeyChanged,
    required TResult Function(List<String>? path, bool deselect) groupSelected,
    required TResult Function(List<String>? path, bool deselect) itemSelected,
    required TResult Function() selectedItemViewToggled,
    required TResult Function(VaultFile newVault, Key masterKey) updated,
    required TResult Function() locked,
    required TResult Function() closed,
  }) {
    return closed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
  }) {
    return closed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(VaultUrl url)? opened,
    TResult Function(Key masterKey)? unlocked,
    TResult Function(Key? masterKey)? masterKeyChanged,
    TResult Function(List<String>? path, bool deselect)? groupSelected,
    TResult Function(List<String>? path, bool deselect)? itemSelected,
    TResult Function()? selectedItemViewToggled,
    TResult Function(VaultFile newVault, Key masterKey)? updated,
    TResult Function()? locked,
    TResult Function()? closed,
    required TResult orElse(),
  }) {
    if (closed != null) {
      return closed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenedEvent value) opened,
    required TResult Function(UnlockedEvent value) unlocked,
    required TResult Function(MasterKeyChangedEvent value) masterKeyChanged,
    required TResult Function(GroupSelectedEvent value) groupSelected,
    required TResult Function(ItemSelectedEvent value) itemSelected,
    required TResult Function(SelectedItemViewToggledEvent value)
        selectedItemViewToggled,
    required TResult Function(UpdatedEvent value) updated,
    required TResult Function(LockedEvent value) locked,
    required TResult Function(ClosedEvent value) closed,
  }) {
    return closed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
  }) {
    return closed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenedEvent value)? opened,
    TResult Function(UnlockedEvent value)? unlocked,
    TResult Function(MasterKeyChangedEvent value)? masterKeyChanged,
    TResult Function(GroupSelectedEvent value)? groupSelected,
    TResult Function(ItemSelectedEvent value)? itemSelected,
    TResult Function(SelectedItemViewToggledEvent value)?
        selectedItemViewToggled,
    TResult Function(UpdatedEvent value)? updated,
    TResult Function(LockedEvent value)? locked,
    TResult Function(ClosedEvent value)? closed,
    required TResult orElse(),
  }) {
    if (closed != null) {
      return closed(this);
    }
    return orElse();
  }
}

abstract class ClosedEvent implements VaultEvent {
  const factory ClosedEvent() = _$ClosedEvent;
}
